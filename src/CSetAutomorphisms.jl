using Catlab.Theories: adom, attr, attrtype, attr, adom, acodom
using Catlab.Present
using Catlab.CategoricalAlgebra.CSetDataStructures: struct_acset

include(joinpath(@__DIR__, "Perms.jl"))
include(joinpath(@__DIR__, "ColorRefine.jl"))

"""
To compute automorphisms of Attributed CSets, we create a pseudo CSet which has
additional components for each data type.

This is inefficient for attributes which have a total order on them
(e.g. integers/strings) since we solve for a canonical permutation of the
attributes. Future work could address this by initializing the coloring with
the 'correct' canonical order.
"""
function pseudo_cset(g::StructACSet{S}
                    )::Tuple{StructACSet, Dict{Symbol,Vector{Any}}} where {S}
  tabs, arrs = collect(ob(S)), collect(hom(S))
  src, tgt = dom(S), codom(S)
  dtabs, darrs = collect(attrtype(S)), collect(attr(S))
  dsrc, dtgt = adom(S), acodom(S)

  # Create copy of schema (+ an extra component for each datatype)
  pres = Presentation(FreeSchema)
  xobs = [Ob(FreeSchema,t) for t in vcat(tabs,dtabs)]
  xobsdic = Dict([t=>Ob(FreeSchema,t) for t in vcat(tabs,dtabs)])
  n = length(tabs)
  for x in xobs add_generator!(pres, x) end

  for (arr, s, t) in zip(map(collect, [arrs, src, tgt])...)
    add_generator!(pres, Hom(arr, xobsdic[s], xobsdic[t]))
  end

  # Add an arrow for each attr and store all possible Data values
  attrvals = Dict([t=>Set() for t in dtabs])
  for (arr, s, t) in zip(darrs, dsrc, dtgt)
    add_generator!(pres, Hom(arr, xobsdic[s], xobsdic[t]))
    union!(attrvals[t], Set(g[arr]))
  end

  # Use Julia ordering to give each value an index
  attrvals = Dict([k=>sort(collect(x)) for (k,x) in collect(attrvals)])

  # Create and populate pseudo-cset
  name = Symbol("Pseudo_$(typeof(g).name.name)")
  expr = struct_acset(name, StructACSet, pres, index=vcat(arrs,darrs))
  eval(expr)
  csettype = eval(name)
  res = Base.invokelatest(eval(name))

  # Copy the original non-attr data
  for t in tabs
    add_parts!(res, t, nparts(g,t))
  end
  for a in arrs
    set_subpart!(res, a, g[a])
  end

  # initialize pseudo data components
  for t in dtabs
    add_parts!(res, t, length(attrvals[t]))
  end

  # Replace data value with an index for each attribute
  for (a,t) in zip(darrs, dtgt)
    fks = [findfirst(==(v), attrvals[t]) for v in g[a]]
    set_subpart!(res, a, fks)
  end

  return res, attrvals
end

"""
Heuristic for total ordering of objects of a CSet. We want things that will
be easily distinguished to be first. Things are very easily distinguished by
in-arrows, and somewhat distinguished by out arrows. So each object gets a
score based on this criteria. We then iterate until convergence.

We use this total ordering to order arrows by their target's score.

TO DO test this heuristic vs random heuristics to see that it's actually
effective.
"""
function order_syms(::StructACSet{S})::Vector{Symbol} where {S}
  os, arrs, srcs, tgts = ob(S), hom(S), dom(S), codom(S)
  function score_obj(obj::Symbol, scores::Dict{Symbol, Pair{Int,Int}})::Pair{Int,Int}
    arr_in = sum([scores[s][1] for (s, t) in zip(srcs, tgts) if t == obj])
    arr_ot = sum([scores[t][2] for (s, t) in zip(srcs, tgts) if s == obj])
    return arr_in => arr_ot
  end
  scores = Dict(zip(os, [(1=>1) for _ in os]))
  oldorder = []
  neworder = sort([(b,a) for (a,b) in collect(scores)])
  while oldorder != neworder
    oldorder = neworder
    scores = Dict([o=>score_obj(o, scores) for o in os])
    neworder = sort([(b,a) for (a,b) in collect(scores)])
  end
  ordobjs = [s for (_,s) in oldorder]
  ordarrs = sort([(findfirst(==(t),ordobjs), h) for (h, t) in zip(arrs, tgts)])
  return [a for (_,a) in ordarrs]
end

"""
Inverse of pseudo_cset. Requires mapping (generated by `pseudo_cset`) of indices
for each Data to the actual data values.
"""
function pseudo_cset_inv(g::StructACSet,
                         orig::StructACSet{S},
                         attrvals::Dict{Symbol,Vector{Any}}
                        )::StructACSet{S} where {S}
  orig = deepcopy(orig)
  arrs = hom(S)
  darrs, dtabs = attr(S), acodom(S)
  for arr in arrs
    set_subpart!(orig, arr, g[arr])
  end
  for (darr,tgt) in zip(darrs, dtabs)
    set_subpart!(orig, darr, attrvals[tgt][g[darr]])
  end
  return orig
end


"""Lexicographic minimum of all automorphisms"""
function canonical_iso(g::StructCSet{S})::StructCSet{S} where {S}
  os = order_syms(g)
  ord(x) = [x[s] for s in os]
  isos = sort([apply_automorphism(g, Dict(a)) for a in autos(g)], by=ord)
  return isempty(isos) ? g : isos[1]
end

"""
Compute automorphisms for the pseudo-cset, but then substitute in
the actual attribute values before evaluating the lexicographic order
"""
function canonical_iso(g::StructACSet{S})::StructACSet{S} where {S}
  os = order_syms(g)
  ord(x) = vcat([x[a] for a in attr(S)],[x[s] for s in os])

  p, avals = pseudo_cset(g)
  isos = sort([pseudo_cset_inv(apply_automorphism(p, Dict(a)), g, avals)
               for a in autos(p)], by=ord)
  return isempty(isos) ? g : isos[1]
end

"""Hash of canonical isomorphism."""
function canonical_hash(g::StructACSet)::UInt64
  return hash(string(canonical_iso(g)))
end

"""Find index at which two vectors diverge (used in `search_tree`)"""
function common(v1::Vector{T}, v2::Vector{T})::Int where {T}
  for (i, (x, y)) in enumerate(zip(v1, v2))
    if x != y
      return i-1
    end
  end
  return i
end


"""
DFS tree of colorings, with edges being choices in how to break symmetry
Goal is to acquire all leaf nodes.

Algorithm from "McKayâ€™s Canonical Graph Labeling Algorithm" by Hartke and
Radcliffe (2009).
"""
function search_tree!(g::StructACSet{S}, res::Vector{CDict},
                     coloring::CDict,
                     split_seq::Vector{Int},
                     tree::Dict{Vector{Int},CDict},
                     perms::Set{Vector{Int}},
                     skip::Set{Vector{Int}}
                    )::Nothing where {S}
  tree[split_seq] = coloring # add the current color to the tree

  # To reduce branching factor, split on the SMALLEST nontrivial partition
  colors_by_size = []
  for (k, v) in coloring
    for color in 1:max0(v)
      n_c = count(==(color), v)
      if n_c > 1
        # Store which table and which color
        push!(colors_by_size, n_c => (k, color))
      end
    end
  end

  if isempty(colors_by_size) # We found a leaf!
    # Construct automorphisms between leaves
    # to possibly prune the search tree. See Figure 4
    tau_inv = invert_perm(coloring)
    for p in perms
      pii = tree[p]
      auto = compose_perms(pii,tau_inv)
      i = common(p, split_seq)
      a = tree[p[1:i]]
      if compose_perms(auto, a) == a
        b = tree[p[1:i+1]]
        c_location = split_seq[1:i+1]
        c = tree[c_location]
        if compose_perms(auto, b) == c
          push!(skip, c_location)
        end
      end
    end
    # Add permutation to the list of results
    push!(perms, split_seq)
    push!(res, coloring)
  else
    sort!(colors_by_size)
    split_tab, split_color = colors_by_size[1][2]
    colors = coloring[split_tab]
    split_inds = findall(==(split_color), colors)
    for split_ind in split_inds
      if  !(split_seq in skip)
        new_coloring = deepcopy(coloring)
        new_seq = vcat(split_seq, [split_ind])
        new_coloring[split_tab][split_ind] = max0(colors) + 1
        refined = color_refine(g; init_color=new_coloring)
        search_tree!(g, res, refined, new_seq, tree, perms, skip)
      end
    end
  end
  return nothing
end

"""Compute the automorphisms of a CSet"""
function autos(g::StructACSet)::Set{CDict}
  res = CDict[]
  search_tree!(g, res, color_refine(g), Int[],
             Dict{Vector{Int},CDict}(),
             Set{Vector{Int}}(),
             Set{Vector{Int}}())
  return Set(res) # all_perms(res)
end

